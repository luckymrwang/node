"use strict";
/*!
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var SpanContext_1 = tslib_1.__importDefault(require("../../trace/context/SpanContext"));
var async_hooks_1 = tslib_1.__importDefault(require("async_hooks"));
var store;
if (async_hooks_1.default.AsyncLocalStorage) {
    store = new async_hooks_1.default.AsyncLocalStorage();
}
else { // Node 10 doesn't have AsyncLocalStore, so recreate it
    var executionAsyncId_1 = async_hooks_1.default.executionAsyncId;
    var asyncLocalStore_1 = {};
    store = {
        getStore: function () {
            return asyncLocalStore_1[executionAsyncId_1()];
        },
        enterWith: function (s) {
            asyncLocalStore_1[executionAsyncId_1()] = s;
        },
    };
    async_hooks_1.default.createHook({
        init: function (asyncId, type, triggerId) {
            asyncLocalStore_1[asyncId] = asyncLocalStore_1[triggerId];
        },
        destroy: function (asyncId) {
            delete asyncLocalStore_1[asyncId];
        },
    }).enable();
}
var ContextManager = /** @class */ (function () {
    function ContextManager() {
    }
    Object.defineProperty(ContextManager.prototype, "asyncState", {
        get: function () {
            var asyncState = store.getStore();
            if (asyncState === undefined) {
                asyncState = { context: new SpanContext_1.default(), spans: [] };
                store.enterWith(asyncState);
            }
            return asyncState;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ContextManager.prototype, "current", {
        get: function () {
            return this.asyncState.context;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ContextManager.prototype, "spans", {
        get: function () {
            return this.asyncState.spans;
        },
        enumerable: false,
        configurable: true
    });
    ContextManager.prototype.spansDup = function () {
        var asyncState = store.getStore();
        if (asyncState === undefined) {
            asyncState = { context: new SpanContext_1.default(), spans: [] };
        }
        else {
            asyncState = { context: asyncState.context, spans: tslib_1.__spreadArrays(asyncState.spans) };
        }
        store.enterWith(asyncState);
        return asyncState.spans;
    };
    ContextManager.prototype.clear = function () {
        store.enterWith(undefined);
    };
    ContextManager.prototype.restore = function (context, spans) {
        store.enterWith({ context: context, spans: spans || [] });
    };
    ContextManager.prototype.withSpan = function (span, callback) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        if (!span.startTime)
            span.start();
        try {
            return callback.apply(void 0, args);
        }
        catch (e) {
            span.error(e);
            throw e;
        }
        finally {
            span.stop();
        }
    };
    ContextManager.prototype.withSpanAwait = function (span, callback) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var e_1;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!span.startTime)
                            span.start();
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, callback.apply(void 0, args)];
                    case 2: return [2 /*return*/, _a.sent()];
                    case 3:
                        e_1 = _a.sent();
                        span.error(e_1);
                        throw e_1;
                    case 4:
                        span.stop();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    return ContextManager;
}());
exports.default = new ContextManager();
//# sourceMappingURL=ContextManager.js.map