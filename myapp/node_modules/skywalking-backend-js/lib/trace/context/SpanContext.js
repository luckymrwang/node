"use strict";
/*!
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var AgentConfig_1 = tslib_1.__importDefault(require("../../config/AgentConfig"));
var DummyContext_1 = tslib_1.__importDefault(require("../../trace/context/DummyContext"));
var DummySpan_1 = tslib_1.__importDefault(require("../../trace/span/DummySpan"));
var Segment_1 = tslib_1.__importDefault(require("../../trace/context/Segment"));
var EntrySpan_1 = tslib_1.__importDefault(require("../../trace/span/EntrySpan"));
var ExitSpan_1 = tslib_1.__importDefault(require("../../trace/span/ExitSpan"));
var LocalSpan_1 = tslib_1.__importDefault(require("../../trace/span/LocalSpan"));
var logging_1 = require("../../logging");
var async_hooks_1 = require("async_hooks");
var ContextManager_1 = tslib_1.__importDefault(require("./ContextManager"));
var Tracing_pb_1 = require("../../proto/language-agent/Tracing_pb");
var EventEmitter_1 = require("../../lib/EventEmitter");
var logger = logging_1.createLogger(__filename);
var SpanContext = /** @class */ (function () {
    function SpanContext() {
        this.spanId = 0;
        this.nSpans = 0;
        this.segment = new Segment_1.default();
    }
    Object.defineProperty(SpanContext.prototype, "parent", {
        get: function () {
            if (ContextManager_1.default.spans.length > 0) {
                return ContextManager_1.default.spans[ContextManager_1.default.spans.length - 1];
            }
            return null;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpanContext.prototype, "parentId", {
        get: function () {
            return this.parent ? this.parent.id : -1;
        },
        enumerable: false,
        configurable: true
    });
    SpanContext.prototype.ignoreCheck = function (operation, type) {
        if (operation.match(AgentConfig_1.default.reIgnoreOperation)) {
            return new DummySpan_1.default({
                context: new DummyContext_1.default(),
                operation: '',
                type: type,
            });
        }
        return undefined;
    };
    SpanContext.prototype.newEntrySpan = function (operation, carrier) {
        if (logger.isDebugEnabled()) {
            logger.debug('Creating entry span', {
                parentId: this.parentId,
                executionAsyncId: async_hooks_1.executionAsyncId(),
            });
        }
        var span = this.ignoreCheck(operation, Tracing_pb_1.SpanType.ENTRY);
        if (span)
            return span;
        var spans = ContextManager_1.default.spansDup();
        var parent = spans[spans.length - 1];
        if (parent && parent.type === Tracing_pb_1.SpanType.ENTRY) {
            span = parent;
            parent.operation = operation;
        }
        else {
            span = new EntrySpan_1.default({
                id: this.spanId++,
                parentId: this.parentId,
                context: this,
                operation: operation,
            });
            if (carrier && carrier.isValid()) {
                span.extract(carrier);
            }
        }
        return span;
    };
    SpanContext.prototype.newExitSpan = function (operation, peer) {
        if (logger.isDebugEnabled()) {
            logger.debug('Creating exit span', {
                parentId: this.parentId,
                executionAsyncId: async_hooks_1.executionAsyncId(),
            });
        }
        var span = this.ignoreCheck(operation, Tracing_pb_1.SpanType.EXIT);
        if (span)
            return span;
        var spans = ContextManager_1.default.spansDup();
        var parent = spans[spans.length - 1];
        if (parent && parent.type === Tracing_pb_1.SpanType.EXIT) {
            span = parent;
        }
        else {
            span = new ExitSpan_1.default({
                id: this.spanId++,
                parentId: this.parentId,
                context: this,
                peer: peer,
                operation: operation,
            });
        }
        return span;
    };
    SpanContext.prototype.newLocalSpan = function (operation) {
        if (logger.isDebugEnabled()) {
            logger.debug('Creating local span', {
                parentId: this.parentId,
                executionAsyncId: async_hooks_1.executionAsyncId(),
            });
        }
        var span = this.ignoreCheck(operation, Tracing_pb_1.SpanType.LOCAL);
        if (span)
            return span;
        ContextManager_1.default.spansDup();
        return new LocalSpan_1.default({
            id: this.spanId++,
            parentId: this.parentId,
            context: this,
            operation: operation,
        });
    };
    SpanContext.prototype.start = function (span) {
        logger.debug('Starting span', {
            span: span.operation,
            spans: ContextManager_1.default.spans,
            nSpans: this.nSpans,
        });
        this.nSpans += 1;
        if (ContextManager_1.default.spans.every(function (s) { return s.id !== span.id; })) {
            ContextManager_1.default.spans.push(span);
        }
        return this;
    };
    SpanContext.prototype.stop = function (span) {
        logger.debug('Stopping span', {
            span: span.operation,
            spans: ContextManager_1.default.spans,
            nSpans: this.nSpans,
        });
        span.finish(this.segment);
        var idx = ContextManager_1.default.spans.indexOf(span);
        if (idx !== -1) {
            ContextManager_1.default.spans.splice(idx, 1);
        }
        if (--this.nSpans === 0) {
            EventEmitter_1.emitter.emit('segment-finished', this.segment);
            ContextManager_1.default.clear();
            return true;
        }
        return false;
    };
    SpanContext.prototype.async = function (span) {
        logger.debug('Async span', {
            span: span.operation,
            spans: ContextManager_1.default.spans,
            nSpans: this.nSpans,
        });
        var idx = ContextManager_1.default.spans.indexOf(span);
        if (idx !== -1) {
            ContextManager_1.default.spans.splice(idx, 1);
        }
        if (this.nSpans === 1) { // this will pass the context to child async task so it doesn't mess with other tasks here
            ContextManager_1.default.clear();
        }
    };
    SpanContext.prototype.resync = function (span) {
        logger.debug('Resync span', {
            span: span.operation,
            spans: ContextManager_1.default.spans,
            nSpans: this.nSpans,
        });
        if (span.context.nSpans === 1) {
            ContextManager_1.default.restore(span.context, [span]);
        }
        else if (ContextManager_1.default.spans.every(function (s) { return s.id !== span.id; })) {
            ContextManager_1.default.spans.push(span);
        }
    };
    SpanContext.prototype.currentSpan = function () {
        return ContextManager_1.default.spans[ContextManager_1.default.spans.length - 1];
    };
    return SpanContext;
}());
exports.default = SpanContext;
//# sourceMappingURL=SpanContext.js.map