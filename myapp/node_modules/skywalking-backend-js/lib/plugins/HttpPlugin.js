"use strict";
/*!
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var url_1 = require("url");
var ContextManager_1 = tslib_1.__importDefault(require("../trace/context/ContextManager"));
var Component_1 = require("../trace/Component");
var Tag_1 = tslib_1.__importDefault(require("../Tag"));
var Tracing_pb_1 = require("../proto/language-agent/Tracing_pb");
var ContextCarrier_1 = require("../trace/context/ContextCarrier");
var on_finished_1 = tslib_1.__importDefault(require("on-finished"));
var HttpPlugin = /** @class */ (function () {
    function HttpPlugin() {
        this.module = 'http';
        this.versions = '*';
    }
    HttpPlugin.prototype.install = function () {
        var http = require('http');
        var https = require('https');
        this.interceptClientRequest(http);
        this.interceptServerRequest(http);
        this.interceptClientRequest(https);
        this.interceptServerRequest(https);
    };
    HttpPlugin.prototype.interceptClientRequest = function (module) {
        var _request = module.request;
        module.request = function () {
            var url = arguments[0];
            var _a = url instanceof url_1.URL
                ? url
                : typeof url === 'string'
                    ? new url_1.URL(url) // TODO: this may throw invalid URL
                    : {
                        host: (url.host || url.hostname || 'unknown') + ':' + (url.port || 80),
                        pathname: url.path || '/',
                    }, host = _a.host, pathname = _a.pathname;
            var operation = pathname.replace(/\?.*$/g, '');
            var span = ContextManager_1.default.current.newExitSpan(operation, host).start();
            var stopped = 0; // compensating if request aborted right after creation 'close' is not emitted
            var stopIfNotStopped = function (err) {
                if (stopped++) {
                    return;
                }
                span.stop();
                if (err) {
                    span.error(err);
                }
            };
            try {
                // TODO: these should go into span class
                if (span.depth === 1) { // only set HTTP if this span is not overridden by a higher level one
                    span.component = Component_1.Component.HTTP;
                    span.layer = Tracing_pb_1.SpanLayer.HTTP;
                }
                if (!span.peer) {
                    span.peer = host;
                }
                var httpURL = host + pathname;
                if (!span.hasTag(httpURL)) {
                    span.tag(Tag_1.default.httpURL(httpURL));
                }
                var req_1 = _request.apply(this, arguments);
                span.inject().items.forEach(function (item) {
                    req_1.setHeader(item.key, item.value);
                });
                req_1.prependListener('response', function (res) {
                    span.resync();
                    span.tag(Tag_1.default.httpStatusCode(res.statusCode));
                    if (res.statusCode && res.statusCode >= 400) {
                        span.errored = true;
                    }
                    if (res.statusMessage) {
                        span.tag(Tag_1.default.httpStatusMsg(res.statusMessage));
                    }
                });
                on_finished_1.default(req_1, stopIfNotStopped);
                span.async();
                return req_1;
            }
            catch (e) {
                stopIfNotStopped(e);
                throw e;
            }
        };
    };
    HttpPlugin.prototype.interceptServerRequest = function (module) {
        var _emit = module.Server.prototype.emit;
        module.Server.prototype.emit = function () {
            if (arguments[0] !== 'request') {
                return _emit.apply(this, arguments);
            }
            var _a = [arguments[1], arguments[2]], req = _a[0], res = _a[1];
            var headers = req.rawHeaders || [];
            var headersMap = {};
            for (var i = 0; i < headers.length / 2; i += 2) {
                headersMap[headers[i]] = headers[i + 1];
            }
            var carrier = ContextCarrier_1.ContextCarrier.from(headersMap);
            var operation = (req.url || '/').replace(/\?.*/g, '');
            var span = ContextManager_1.default.current.newEntrySpan(operation, carrier).start();
            span.component = Component_1.Component.HTTP_SERVER;
            span.layer = Tracing_pb_1.SpanLayer.HTTP;
            span.peer = req.headers.host || '';
            span.tag(Tag_1.default.httpURL(span.peer + req.url));
            var stopped = 0;
            var stopIfNotStopped = function (err) {
                if (!stopped++) {
                    span.stop();
                    span.tag(Tag_1.default.httpStatusCode(res.statusCode));
                    if (res.statusCode && res.statusCode >= 400) {
                        span.errored = true;
                    }
                    if (err) {
                        span.error(err);
                    }
                    if (res.statusMessage) {
                        span.tag(Tag_1.default.httpStatusMsg(res.statusMessage));
                    }
                }
            };
            on_finished_1.default(res, stopIfNotStopped);
            try {
                return _emit.apply(this, arguments);
            }
            catch (e) {
                stopIfNotStopped(e);
                throw e;
            }
        };
    };
    return HttpPlugin;
}());
// noinspection JSUnusedGlobalSymbols
exports.default = new HttpPlugin();
//# sourceMappingURL=HttpPlugin.js.map